package net.minecraft.nbt;

import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTTagListHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTTagCompoundHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.NBTTagStringHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.NBTTagByteHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.NBTTagShortHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.NBTTagIntHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.NBTTagLongHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.NBTTagFloatHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.NBTTagDoubleHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.NBTTagByteArrayHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.NBTTagIntArrayHandle;
import com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.NBTTagLongArrayHandle;

class NBTBase {
#if version >= 1.18
    public abstract byte getTypeId:getId();
    public abstract (Object) NBTBase raw_clone:copy();
#else
    public abstract byte getTypeId();
    public abstract (Object) NBTBase raw_clone:clone();
#endif

    public static NBTBaseHandle createHandle(Object instance) {
        if (!(instance instanceof NBTBase)) {
            throw new IllegalArgumentException("Input is not an instance of NBTBase");
        }
        return com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.createHandleForData(instance);
    }

    <code>
    public com.bergerkiller.bukkit.common.nbt.CommonTag toCommonTag() {
        return new com.bergerkiller.bukkit.common.nbt.CommonTag(this);
    }
    public abstract NBTBaseHandle clone();
    public abstract Object getData();

    public final String toPrettyString() {
        StringBuilder str = new StringBuilder(100);
        toPrettyString(str, 0);
        return str.toString();
    }

    public void toPrettyString(StringBuilder str, int indent) {
        while (indent-- > 0) {
            str.append("  ");
        }
        Object data = getData();
        if (data == null) {
            str.append("UNKNOWN[").append(getTypeId()).append("]");
        } else {
            Class<?> unboxedType = com.bergerkiller.mountiplex.reflection.util.BoxedType.getUnboxedType(data.getClass());
            if (unboxedType != null) {
                str.append(unboxedType.getSimpleName());
            } else {
                str.append(data.getClass().getSimpleName());
            }
            str.append(": ").append(data);
        }
    }

    private static final class TypeInfo {
        public final Class<?> dataType;
        public final Template.Class<? extends NBTBaseHandle> handleClass;
        public final java.util.function.Function<Object, Object> constructor;
        public final java.util.function.Function<Object, Object> get_data;

        public TypeInfo(Class<?> dataType,
                        Template.Class<? extends NBTBaseHandle> handleClass,
                        java.util.function.Function<Object, Object> constructor,
                        java.util.function.Function<Object, Object> get_data)
        {
            this.dataType = dataType;
            this.handleClass = handleClass;
            this.constructor = constructor;
            this.get_data = get_data;
        }
    }

    private static final com.bergerkiller.bukkit.common.collections.ClassMap<TypeInfo> typeInfoLookup = new com.bergerkiller.bukkit.common.collections.ClassMap<TypeInfo>();
    private static final TypeInfo toStringFallbackTypeInfo = new TypeInfo(
        String.class, NBTTagStringHandle.T,
        data -> NBTTagStringHandle.T.create.raw.invoke(com.bergerkiller.bukkit.common.conversion.Conversion.toString.convert(data, "")),
        java.util.function.Function.identity()
    );

    protected static void registerTypeInfo(Class<?> dataType,
                                         Template.Class<? extends NBTBaseHandle> handleClass,
                                         java.util.function.Function<Object, Object> constructor,
                                         java.util.function.Function<Object, Object> get_data)
    {
        TypeInfo data_typeInfo = new TypeInfo(dataType, handleClass, constructor, java.util.function.Function.identity());
        typeInfoLookup.put(dataType, data_typeInfo);
        Class<?> boxedDataType = com.bergerkiller.mountiplex.reflection.util.BoxedType.getBoxedType(dataType);
        if (boxedDataType != null) {
            typeInfoLookup.put(boxedDataType, data_typeInfo);
        }

        // NBTBase type -> return identity
        typeInfoLookup.put(handleClass.getType(), new TypeInfo(dataType, handleClass,
            java.util.function.Function.identity(), get_data));

        // NBTBaseHandle type -> return getRaw()
        typeInfoLookup.put(handleClass.getHandleType(), new TypeInfo(dataType, handleClass,
            handle -> ((Template.Handle) handle).getRaw(),
            handle -> get_data.apply(((Template.Handle) handle).getRaw())));

        // Forward initialize the Template Class handle builder to fix a reported linkage error
        handleClass.createHandle(null, true);
    }

    private static TypeInfo findTypeInfo(Object data) {
        if (data == null) {
            throw new IllegalArgumentException("Can not find tag type information for null data");
        }

        TypeInfo info = typeInfoLookup.get(data.getClass());
        if (info != null) {
            return info;
        }
        if (data instanceof com.bergerkiller.bukkit.common.nbt.CommonTag) {
            final TypeInfo handle_info = findTypeInfo(((com.bergerkiller.bukkit.common.nbt.CommonTag) data).getRawHandle());
            return new TypeInfo(
                handle_info.dataType, handle_info.handleClass,
                tag -> ((com.bergerkiller.bukkit.common.nbt.CommonTag) data).getRawHandle(),
                tag -> handle_info.get_data.apply(((com.bergerkiller.bukkit.common.nbt.CommonTag) data).getRawHandle())
            );
        }
        return toStringFallbackTypeInfo;
    }

    public static boolean isDataSupportedNatively(Object data) {
        return typeInfoLookup.get(data) != null || data instanceof com.bergerkiller.bukkit.common.nbt.CommonTag;
    }

    public static Object getDataForHandle(Object handle) {
        return findTypeInfo(handle).get_data.apply(handle);
    }

    public static Object createRawHandleForData(Object data) {
        return findTypeInfo(data).constructor.apply(data);
    }

    public static NBTBaseHandle createHandleForData(Object data) {
        TypeInfo info = findTypeInfo(data);
        return info.handleClass.createHandle(info.constructor.apply(data));
    }

    static {
        // Initialize the classes of all known NBT implementations to register them
        try {
            Class.forName(NBTTagStringHandle.class.getName());
            Class.forName(NBTTagByteHandle.class.getName());
            Class.forName(NBTTagShortHandle.class.getName());
            Class.forName(NBTTagIntHandle.class.getName());
            Class.forName(NBTTagLongHandle.class.getName());
            Class.forName(NBTTagFloatHandle.class.getName());
            Class.forName(NBTTagDoubleHandle.class.getName());
            Class.forName(NBTTagByteArrayHandle.class.getName());
            Class.forName(NBTTagIntArrayHandle.class.getName());
            Class.forName(NBTTagLongArrayHandle.class.getName());
            Class.forName(NBTTagListHandle.class.getName());
            Class.forName(NBTTagCompoundHandle.class.getName());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    </code>

    class NBTTagString extends NBTBase {
#if version >= 1.18
        public static (NBTBaseHandle.NBTTagStringHandle) NBTTagString create:valueOf(String data);
#elseif version >= 1.15
        public static (NBTBaseHandle.NBTTagStringHandle) NBTTagString create:a(String data);
#else
        public static (NBTBaseHandle.NBTTagStringHandle) NBTTagString create(String data) { return new NBTTagString(data); }
#endif

        // Overrides getData() in NBTBase
#if version >= 1.18
        public String getData:getAsString();
#elseif version >= 1.13.2
        public String getData:asString();
#elseif version >= 1.13
        public String getData:b_();
#elseif version >= 1.10.2
        public String getData:c_();
#else
        public String getData:a_();
#endif

        <code>
        static {
            registerTypeInfo(String.class, T, T.create.raw::invoke, T.getData::invoke);
        }

        public NBTBaseHandle.NBTTagStringHandle clone() {
            return com.bergerkiller.bukkit.common.internal.CommonCapabilities.IMMUTABLE_NBT_PRIMITIVES ? this : createHandle(raw_clone());
        }
        </code>
    }

    class NBTTagByte extends NBTBase {
#if version >= 1.18
        public static (NBTBaseHandle.NBTTagByteHandle) NBTTagByte create:valueOf(byte data);
#elseif version >= 1.15
        public static (NBTBaseHandle.NBTTagByteHandle) NBTTagByte create:a(byte data);
#else
        public static (NBTBaseHandle.NBTTagByteHandle) NBTTagByte create(byte data) { return new NBTTagByte(data); }
#endif
#if version >= 1.18
        public byte getByteData:getAsByte();
#elseif version >= 1.13.2
        public byte getByteData:asByte();
#elseif version >= 1.10.2
        public byte getByteData:g();
#else
        public byte getByteData:f();
#endif

        <code>
        static {
            registerTypeInfo(byte.class, T, T.create.raw::invoke, T.getByteData::invoke);
        }

        public NBTBaseHandle.NBTTagByteHandle clone() {
            return com.bergerkiller.bukkit.common.internal.CommonCapabilities.IMMUTABLE_NBT_PRIMITIVES ? this : createHandle(raw_clone());
        }
        public Byte getData() { return Byte.valueOf(getByteData()); }
        </code>
    }

    class NBTTagShort extends NBTBase {
#if version >= 1.18
        public static (NBTBaseHandle.NBTTagShortHandle) NBTTagShort create:valueOf(short data);
#elseif version >= 1.15
        public static (NBTBaseHandle.NBTTagShortHandle) NBTTagShort create:a(short data);
#else
        public static (NBTBaseHandle.NBTTagShortHandle) NBTTagShort create(short data) { return new NBTTagShort(data); }
#endif
#if version >= 1.18
        public short getShortData:getAsShort();
#elseif version >= 1.13.2
        public short getShortData:asShort();
#elseif version >= 1.10.2
        public short getShortData:f();
#else
        public short getShortData:e();
#endif

        <code>
        static {
            registerTypeInfo(short.class, T, T.create.raw::invoke, T.getShortData::invoke);
        }

        public static Object createRaw(Object data) { return T.create.raw.invoke(data); }
        public NBTBaseHandle.NBTTagShortHandle clone() {
            return com.bergerkiller.bukkit.common.internal.CommonCapabilities.IMMUTABLE_NBT_PRIMITIVES ? this : createHandle(raw_clone());
        }
        public Short getData() { return Short.valueOf(getShortData()); }
        </code>
    }

    class NBTTagInt extends NBTBase {
#if version >= 1.18
        public static (NBTBaseHandle.NBTTagIntHandle) NBTTagInt create:valueOf(int data);
#elseif version >= 1.15
        public static (NBTBaseHandle.NBTTagIntHandle) NBTTagInt create:a(int data);
#else
        public static (NBTBaseHandle.NBTTagIntHandle) NBTTagInt create(int data) { return new NBTTagInt(data); }
#endif
#if version >= 1.18
        public int getIntegerData:getAsInt();
#elseif version >= 1.13.2
        public int getIntegerData:asInt();
#elseif version >= 1.10.2
        public int getIntegerData:e();
#else
        public int getIntegerData:d();
#endif

        <code>
        static {
            registerTypeInfo(int.class, T, T.create.raw::invoke, T.getIntegerData::invoke);
        }

        public NBTBaseHandle.NBTTagIntHandle clone() {
            return com.bergerkiller.bukkit.common.internal.CommonCapabilities.IMMUTABLE_NBT_PRIMITIVES ? this : createHandle(raw_clone());
        }
        public Integer getData() { return Integer.valueOf(getIntegerData()); }
        </code>
    }

    class NBTTagLong extends NBTBase {
#if version >= 1.18
        public static (NBTBaseHandle.NBTTagLongHandle) NBTTagLong create:valueOf(long data);
#elseif version >= 1.15
        public static (NBTBaseHandle.NBTTagLongHandle) NBTTagLong create:a(long data);
#else
        public static (NBTBaseHandle.NBTTagLongHandle) NBTTagLong create(long data) { return new NBTTagLong(data); }
#endif
#if version >= 1.18
        public long getLongData:getAsLong();
#elseif version >= 1.13.2
        public long getLongData:asLong();
#elseif version >= 1.10.2
        public long getLongData:d();
#else
        public long getLongData:c();
#endif

        <code>
        static {
            registerTypeInfo(long.class, T, T.create.raw::invoke, T.getLongData::invoke);
        }

        public NBTBaseHandle.NBTTagLongHandle clone() {
            return com.bergerkiller.bukkit.common.internal.CommonCapabilities.IMMUTABLE_NBT_PRIMITIVES ? this : createHandle(raw_clone());
        }
        public Long getData() { return Long.valueOf(getLongData()); }
        </code>
    }

    class NBTTagFloat extends NBTBase {
#if version >= 1.18
        public static (NBTBaseHandle.NBTTagFloatHandle) NBTTagFloat create:valueOf(float data);
#elseif version >= 1.15
        public static (NBTBaseHandle.NBTTagFloatHandle) NBTTagFloat create:a(float data);
#else
        public static (NBTBaseHandle.NBTTagFloatHandle) NBTTagFloat create(float data) { return new NBTTagFloat(data); }
#endif
#if version >= 1.18
        public float getFloatData:getAsFloat();
#elseif version >= 1.13.2
        public float getFloatData:asFloat();
#elseif version >= 1.10.2
        public float getFloatData:i();
#else
        public float getFloatData:h();
#endif

        <code>
        static {
            registerTypeInfo(float.class, T, T.create.raw::invoke, T.getFloatData::invoke);
        }

        public NBTBaseHandle.NBTTagFloatHandle clone() {
            return com.bergerkiller.bukkit.common.internal.CommonCapabilities.IMMUTABLE_NBT_PRIMITIVES ? this : createHandle(raw_clone());
        }
        public Float getData() { return Float.valueOf(getFloatData()); }
        </code>
    }

    class NBTTagDouble extends NBTBase {
#if version >= 1.18
        public static (NBTBaseHandle.NBTTagDoubleHandle) NBTTagDouble create:valueOf(double data);
#elseif version >= 1.15
        public static (NBTBaseHandle.NBTTagDoubleHandle) NBTTagDouble create:a(double data);
#else
        public static (NBTBaseHandle.NBTTagDoubleHandle) NBTTagDouble create(double data) { return new NBTTagDouble(data); }
#endif

#if version >= 1.18
        public double getDoubleData:getAsDouble();
#elseif forge_nms_obfuscated
        public double getDoubleData:h();
#elseif version >= 1.11
        public double getDoubleData:asDouble();
#elseif version >= 1.10.2
        public double getDoubleData:h();
#else
        public double getDoubleData:g();
#endif

        <code>
        static {
            registerTypeInfo(double.class, T, T.create.raw::invoke, T.getDoubleData::invoke);
        }

        public NBTBaseHandle.NBTTagDoubleHandle clone() {
            return com.bergerkiller.bukkit.common.internal.CommonCapabilities.IMMUTABLE_NBT_PRIMITIVES ? this : createHandle(raw_clone());
        }
        public Double getData() { return Double.valueOf(getDoubleData()); }
        </code>
    }

    class NBTTagByteArray extends NBTBase {
        public static (NBTBaseHandle.NBTTagByteArrayHandle) NBTTagByteArray create(byte[] data) { return new NBTTagByteArray(data); }
#if version >= 1.18
        public byte[] getData:getAsByteArray();
#elseif version >= 1.14
        public byte[] getData:getBytes();
#else
        public byte[] getData:c();
#endif

        <code>
        static {
            registerTypeInfo(byte[].class, T, T.create.raw::invoke, T.getData::invoke);
        }
        </code>
    }

    class NBTTagIntArray extends NBTBase {
        public static (NBTBaseHandle.NBTTagIntArrayHandle) NBTTagIntArray create(int[] data) { return new NBTTagIntArray(data); }
#if version >= 1.18
        public int[] getData:getAsIntArray();
#elseif version >= 1.14
        public int[] getData:getInts();
#elseif version >= 1.10.2
        public int[] getData:d();
#else
        public int[] getData:c();
#endif

        <code>
        static {
            registerTypeInfo(int[].class, T, T.create.raw::invoke, T.getData::invoke);
        }
        </code>
    }

    // Since MC 1.12
    optional class NBTTagLongArray extends NBTBase {
        public static (NBTBaseHandle.NBTTagLongArrayHandle) NBTTagLongArray create(long[] data) { return new NBTTagLongArray(data); }
#if version >= 1.18
        public long[] getData:getAsLongArray();
#elseif version >= 1.14
        public long[] getData:getLongs();
#elseif version >= 1.13
        public long[] getData:d();
#elseif version >= 1.12
        public long[] getData() {
            #require net.minecraft.nbt.NBTTagLongArray private long[] data_field:b;
            return instance#data_field;
        }
#else
        public long[] getData() {
            throw new UnsupportedOperationException("NBTTagLongArray is not available");
        }
#endif

        <code>
        static {
            if (T.isAvailable()) {
                registerTypeInfo(long[].class, T, T.create.raw::invoke, T.getData::invoke);
            }
        }
        </code>
    }
}

class NBTTagList extends NBTBase {
#if version >= 1.18
    #require net.minecraft.nbt.NBTBase public abstract byte getTagTypeId:getId();
#else
    #require net.minecraft.nbt.NBTBase public abstract byte getTagTypeId:getTypeId();
#endif

    // Results in getData() being added, which overrides the one in NBTBase
    private readonly (List<NBTBaseHandle>) List<NBTBase> data:list;

    public static (NBTTagListHandle) NBTTagList createEmpty() {
        return new NBTTagList();
    }

    public static (NBTTagListHandle) NBTTagList create(java.util.Collection<?> data) {
        NBTTagList result = new NBTTagList();
        if (!data.isEmpty()) {
            java.util.Iterator iter = data.iterator();
            com.bergerkiller.mountiplex.reflection.declarations.Template.Method add_method;
            add_method = (com.bergerkiller.mountiplex.reflection.declarations.Template.Method) com.bergerkiller.generated.net.minecraft.nbt.NBTTagListHandle.T.add.raw;
            while (iter.hasNext()) {
                Object element = iter.next();
                if (!(element instanceof NBTBase)) {
                    element = com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.createRawHandleForData(element);
                }
                add_method.invoke(result, element);
            }
        }
        return result;
    }

    <code>
    public NBTTagListHandle clone() {
        return createHandle(raw_clone());
    }
    </code>

    public int size();

#if version >= 1.18
    public boolean isEmpty();
#elseif forge_nms_obfuscated
    public boolean isEmpty:b_();
#else
    public boolean isEmpty();
#endif

#if version >= 1.18
    public (byte) byte getElementTypeId:getElementType();
#elseif version >= 1.17
    public (byte) byte getElementTypeId:e();
#elseif version >= 1.16
    public (byte) byte getElementTypeId:d_();
#elseif version >= 1.14
    public (byte) int getElementTypeId:a_();
#elseif version >= 1.13
    public (byte) int getElementTypeId:d();
#elseif version >= 1.10.2
    public (byte) int getElementTypeId:g();
#elseif version >= 1.9
    public (byte) int getElementTypeId:d();
#else
    public (byte) int getElementTypeId:f();
#endif

#if version >= 1.13
    public (NBTBaseHandle) NBTBase get_at:get(int index);
#elseif version >= 1.12
    public (NBTBaseHandle) NBTBase get_at:i(int index);
#elseif version >= 1.9
    public (NBTBaseHandle) NBTBase get_at:h(int index);
#else
    public (NBTBaseHandle) NBTBase get_at:g(int index);
#endif

#if version >= 1.14
    public void clear();
    public (NBTBaseHandle) NBTBase set_at:set(int index, (NBTBaseHandle) NBTBase nbt_value);
    public (NBTBaseHandle) NBTBase remove_at:remove(int index);
    public void add_at:add(int index, (NBTBaseHandle) NBTBase value);

    public boolean add((NBTBaseHandle) NBTBase value) {
        instance.add(value);
        return true;
    }
#else
    #require net.minecraft.nbt.NBTTagList private java.util.List list;
    #require net.minecraft.nbt.NBTTagList private byte type;

    public void clear() {
        java.util.List list = instance#list;
        list.clear();
        instance#type = (byte) 0;
    }

    public (NBTBaseHandle) NBTBase set_at(int index, (NBTBaseHandle) NBTBase nbt_value) {
        byte list_type = instance#type;
        if (list_type != 0 && list_type != nbt_value#getTagTypeId()) {
            throw new UnsupportedOperationException("Trying to set tag of type " +
                nbt_value#getTagTypeId() + " in list of " + list_type);
        }
  #if version >= 1.13
        NBTBase old_value = instance.get(index);
  #elseif version >= 1.12
        NBTBase old_value = instance.i(index);
  #elseif version >= 1.9
        NBTBase old_value = instance.h(index);
  #else
        NBTBase old_value = instance.g(index);
  #endif
  #if version >= 1.18
        instance.setTag(index, nbt_value);
  #else
        instance.a(index, nbt_value);
  #endif
        return old_value;
    }

    public void add_at(int index, (NBTBaseHandle) NBTBase value) {
        byte list_type = instance#type;
        if (list_type == 0) {
            instance#type = value#getTagTypeId();
        } else if (list_type != value#getTagTypeId()) {
            throw new UnsupportedOperationException("Trying to add tag of type " +
                value#getTagTypeId() + " to list of " + list_type);
        }
        java.util.List list = instance#list;
        list.add(index, value);
        return true;
    }

    public (NBTBaseHandle) NBTBase remove_at(int index) {
  #if version >= 1.9
        NBTBase removed = instance.remove(index);
  #else
        NBTBase removed = instance.a(index);
  #endif
  #if version >= 1.18
        if (instance.isEmpty()) {
  #elseif forge_nms_obfuscated
        if (instance.b_()) {
  #else
        if (instance.isEmpty()) {
  #endif
            instance#type = (byte) 0;
        }
        return removed;
    }

    public boolean add((NBTBaseHandle) NBTBase value) {
  #if version >= 1.13
        if (!instance.add(value)) {
            byte list_type = instance#type;
            throw new UnsupportedOperationException("Trying to add tag of type " +
                value#getTagTypeId() + " to list of " + list_type);
        }
        return true;
  #else
        byte list_type = instance#type;
        if (list_type != 0 && list_type != value.getTypeId()) {
            throw new UnsupportedOperationException("Trying to add tag of type " +
                value#getTagTypeId() + " to list of " + list_type);
        }
        instance.add(value);
        return true;
  #endif
    }
#endif

    <code>
    static {
        registerTypeInfo(java.util.Collection.class, T, T.create.raw::invoke, T.data.raw::get);
    }

    public com.bergerkiller.bukkit.common.nbt.CommonTagList toCommonTag() {
        return new com.bergerkiller.bukkit.common.nbt.CommonTagList(this);
    }

    @Override
    public void toPrettyString(StringBuilder str, int indent) {
        for (int i = 0; i < indent; i++) {
            str.append("  ");
        }
        List<NBTBaseHandle> values = getData();
        str.append("TagList: ").append(values.size()).append(" entries [");
        for (NBTBaseHandle value : values) {
            str.append('\n');
            value.toPrettyString(str, indent + 1);
        }
        if (!values.isEmpty()) {
            str.append('\n');
            for (int i = 0; i < indent; i++) {
                str.append("  ");
            }
        }
        str.append(']');
    }
    </code>
}

class NBTTagCompound extends NBTBase {
    // Results in getData() being added, which overrides the one in NBTBase
#if version >= 1.17
    private final readonly (Map<String, NBTBaseHandle>) Map<String, NBTBase> data:tags;
#else
    private final readonly (Map<String, NBTBaseHandle>) Map<String, NBTBase> data:map;
#endif

    public static (NBTTagCompoundHandle) NBTTagCompound createEmpty() { return new NBTTagCompound(); }

    public static (NBTTagCompoundHandle) NBTTagCompound create(java.util.Map<String, ?> map) {
        NBTTagCompound result = new NBTTagCompound();
        if (!map.isEmpty()) {
            java.util.Iterator iter = map.entrySet().iterator();
            while (iter.hasNext()) {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                Object value = entry.getValue();
                NBTBase nbt_value;
                if (value instanceof NBTBase) {
                    nbt_value = (NBTBase) value;
                } else {
                    nbt_value = (NBTBase) com.bergerkiller.generated.net.minecraft.nbt.NBTBaseHandle.createRawHandleForData(value);
                }
#if version >= 1.18
                result.put((String) entry.getKey(), nbt_value);
#else
                result.set((String) entry.getKey(), nbt_value);
#endif
            }
        }
        return result;
    }

    <code>
    public NBTTagCompoundHandle clone() {
        return createHandle(raw_clone());
    }
    </code>

#if version >= 1.18
    public boolean isEmpty();
#elseif forge_nms_obfuscated
    public boolean isEmpty:b_();
#else
    public boolean isEmpty();
#endif

#if version >= 1.18
    public int size();
#elseif version >= 1.15
    public int size:e();
#elseif version >= 1.9
    public int size:d();
#else
    public int size() {
        return instance.c().size();
    }
#endif

#if version >= 1.18
    public Set<String> getKeys:getAllKeys();
#elseif version >= 1.13
    public Set<String> getKeys();
#else
    public Set<String> getKeys:c();
#endif

    public void remove(String key);

#if version >= 1.18
    public (NBTBaseHandle) NBTBase put(String key, (NBTBaseHandle) NBTBase value);
#elseif version >= 1.14
    public (NBTBaseHandle) NBTBase put:set(String key, (NBTBaseHandle) NBTBase value);
#else
    public (NBTBaseHandle) NBTBase put(String key, (NBTBaseHandle) NBTBase value) {
        NBTBase prev_value = instance.get(key);
        instance.set(key, value);
        return prev_value;
    }
#endif

    public (NBTBaseHandle) NBTBase get(String key);

#if version >= 1.18
    public boolean containsKey:contains(String key);
#else
    public boolean containsKey:hasKey(String key);
#endif

    public static (NBTBaseHandle) NBTBase fromMojangson(String mojangson) {
        try {
#if version >= 1.18
            return MojangsonParser.parseTag(mojangson);
#else
            return MojangsonParser.parse(mojangson);
#endif
        } catch (Throwable t) {
            return null;
        }
    }

    <code>
    static {
        registerTypeInfo(java.util.Map.class, T, T.create.raw::invoke, T.data.raw::get);
    }

    public com.bergerkiller.bukkit.common.nbt.CommonTagCompound toCommonTag() {
        return new com.bergerkiller.bukkit.common.nbt.CommonTagCompound(this);
    }

    @Override
    public void toPrettyString(StringBuilder str, int indent) {
        for (int i = 0; i < indent; i++) {
            str.append("  ");
        }
        Map<String, NBTBaseHandle> values = getData();
        str.append("TagCompound: ").append(values.size()).append(" entries {");
        for (Map.Entry<String, NBTBaseHandle> entry : values.entrySet()) {
            str.append('\n');
            for (int i = 0; i <= indent; i++) {
                str.append("  ");
            }
            str.append(entry.getKey()).append(" = ");
            int startOffset = str.length();
            entry.getValue().toPrettyString(str, indent + 1);
            str.delete(startOffset, startOffset + 2 * (indent + 1));
        }
        if (!values.isEmpty()) {
            str.append('\n');
            for (int i = 0; i < indent; i++) {
                str.append("  ");
            }
        }
        str.append('}');
    }
    </code>
}

class NBTCompressedStreamTools {
#if version >= 1.18
    // Uncompressed tag
    public static void uncompressed_writeTag:writeUnnamedTag((NBTBaseHandle) NBTBase nbtbase, java.io.DataOutput dataoutput);
    public static (NBTBaseHandle) NBTBase uncompressed_readTag(java.io.DataInput datainput) {
        #require net.minecraft.nbt.NBTCompressedStreamTools private static NBTBase readUnnamedTag(java.io.DataInput datainput, int i, NBTReadLimiter nbtreadlimiter);
        return #readUnnamedTag(datainput, 0, NBTReadLimiter.a);
    }

    // Uncompressed tag compound
    public static void uncompressed_writeTagCompound:write((NBTTagCompoundHandle) NBTTagCompound nbttagcompound, java.io.DataOutput dataoutput);
    public static (NBTTagCompoundHandle) NBTTagCompound uncompressed_readTagCompound(java.io.DataInput datainput) {
        return NBTCompressedStreamTools.read(datainput, NBTReadLimiter.a);
    }

    // Compressed tag compound
    public static (NBTTagCompoundHandle) NBTTagCompound compressed_readTagCompound:readCompressed(java.io.InputStream inputstream);
    public static void compressed_writeTagCompound:writeCompressed((NBTTagCompoundHandle) NBTTagCompound nbttagcompound, java.io.OutputStream outputstream);
#else
    // Uncompressed tag
    private static void uncompressed_writeTag:a((NBTBaseHandle) NBTBase nbtbase, java.io.DataOutput dataoutput);
    public static (NBTBaseHandle) NBTBase uncompressed_readTag(java.io.DataInput datainput) {
        #require net.minecraft.nbt.NBTCompressedStreamTools private static NBTBase readTag:a(java.io.DataInput datainput, int i, NBTReadLimiter nbtreadlimiter);
        return #readTag(datainput, 0, NBTReadLimiter.a);
    }

    // Uncompressed tag compound
    public static void uncompressed_writeTagCompound:a((NBTTagCompoundHandle) NBTTagCompound nbttagcompound, java.io.DataOutput dataoutput);
    public static (NBTTagCompoundHandle) NBTTagCompound uncompressed_readTagCompound(java.io.DataInput datainput) {
        return NBTCompressedStreamTools.a(datainput, NBTReadLimiter.a);
    }

    // Compressed tag compound
    public static (NBTTagCompoundHandle) NBTTagCompound compressed_readTagCompound:a(java.io.InputStream inputstream);
    public static void compressed_writeTagCompound:a((NBTTagCompoundHandle) NBTTagCompound nbttagcompound, java.io.OutputStream outputstream);
#endif
}